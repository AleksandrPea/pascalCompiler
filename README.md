# pascalCompiler
<h2>Опис мови програмування</h2>

Створена мова програмування(яка є дуже подібною до мови Pascal) має 4 типи даних: цілочисельний(integer, 32 біт), з плаваючою точкою(float, 64 біт), булевий(boolean) та рядковий(string). Ця мова – строго типізована, де float a := 3 це помилка, бо 3 – це константа цілочисельного типу.

Також ця мова є регістро-залежною.

Граматика вхідної мови містить наступні лексеми: "program", "var","integer", float","boolean","string", "if", "then", "else","begin", "end", "while", "do", "for", "to", "repeat", "until","true", "false", "or", "and", "div", "mod", "not" та ‘;’ ‘:’ ‘,’ ‘.’ ‘(’ ‘)’ ‘[‘ ‘]’ ‘=’ ‘< >’ ‘<’ ‘>’ ‘<=’ ‘>=’ ‘*’ ‘/’ ‘+’ ‘-‘ ‘:=’ ‘ ’ ’.

У мові реалізовані 3 цикли(for, з перед-умовою, пост-умовою). Приклад циклу for:

for i := 1 to 4 do begin … end;

Початковий індекс та кінцевий не можуть бути змінними.

Для integer та float реалізовані наступні арифметичні операції : додавання(+), віднімання(-), ділення(div та / відповідно), множення(*), отримання залишку(mod - тільки для цілочисельного типу), унарні операції + та -; всі можливі операції порівняння. Для boolean реалізовані логічні операції : АБО, І, НЕ. Додатково до цього підтримуються оператори: float:sqrt(float), printFloat(float), printInteger(integer), printBoolean(boolean), print(string), println(string).

<h2>Лексичний аналізатор</h2>
Лексичний аналізатор побудований за допомогою задання ліволінійної автоматної граматики, яка програмно перетворюється у відповідний детермінований кінцевий автомат. Таким чином, у даній роботі розроблений <i>генератор лексичних аналізаторів</i>(клас <b>LexicalAnalyzer</b>), який на вході приймає лівонійну регулярну граматику у вигляді об’єкту класу <b>RegularGrammar</b>, масиви роздільників та ключових слів. Головне обмеження, яке накладається на граматику, це виключення правил з однаковою правою частиною.

Код задання граматики лексем для мови Pascal, яка не є вичерпною, можна знайти в класі <b>PascalAnalyzer</b>.

<h2>Синтаксичний аналізатор</h2>
Синтаксичний аналізатор побудований за допомогою задання LL(1) граматики(клас <b>Grammar</b>). LL(1) граматика може містити правила виду: A -> α | ε, де α – будь-яка послідовність терміналів та нетерміналів, ε – пустий символ. Таким чином, у даній роботі розроблений <i>генератор низхідних синтаксичних аналізаторів</i>(клас <b>Parser</b>). Для вхідної граматики не дозволяються:

- правила з лівою рекурсією;
- правила, що мають хоча б один однаковий first-символ. Наприклад A -> a | aB.

Для кожної LL(1) граматики можна побудувати детермінований автомат с пам’яттю(стеком), що розпізнає сентенційні форми мови, яку описує граматика.

За рахунок запам’ятовування правил, які були використані при синтаксичному розборі, будується дерево розбору(клас <b>Node</b>).

Код задання синтаксичних конструкцій для мови Pascal, яка не є вичерпною, можна знайти в класі <b>PascalParser</b>.

<h2>Cемантичний аналізатор</h2>
Створені прості класи, які відображають певні синтаксичні конструкції(наприклад BinaryOp) та запрограмоване перетворення дерева розбору в абстрактне синтаксичне дерево(AST).

Також створена конкретна реалізація інтерфейсу <b>AstVisitor</b> – <b>TypeChecker</b>, який і є семантичним аналізатором. Вхідними даними для нього є : вершина дерева AST, та таблиця операторних типів у вигляді об’єкту класу <b>OperatorTable</b>. У методах visit( ) перевіряються типи аргументів операторів, змінні(чи була оголошена) та розшукуються даремні цикли та if-и, що за умову мають булеву константу(true або false).

Як результат роботи семантичного аналізатора в даній роботі це таблиця змінних, що для кожної оголошеної змінної містить її тип.

<h2>Генератор проміжного коду</h2>
Генератор <b>IrGenerator</b> являється конкретною реалізацією <b>AstVisitor</b> і його головним завданням є перетворення дерева синтаксичних контрукцій у більш конкретний список проміжних команд. Окрім цього, він доповнює створену раніше таблицю змінних новими тимчасовими(temp) змінними.

<h2>Генератор цільового(asm) коду</h2>
Генератор цільового коду в даній роботі є <b>IA32CodeGenerator</b>, який використовує конкретну реалізацію інтерфейсу <b>IrVisitor</b> – <b>IA32ProgramVisitor</b>. Його завданням є побудова програми на masm у вигляді списку рядків. Вхідними даними є таблиця змінних та список проміжних команд.

Окрім цього <b>IA32ProgramVisitor</b> використовує клас <b>IA32Operators</b>, який є ключовим. В ньому описані перетворення всіх стандартних операторів з класу <b>StandardTypes</b>. Також цей клас для кожного іменованого операторного типу(об’єкт <b>NamedType</b>) може поставити у відповідність певний об’єкт типу <b>IA32Operator</b>, який має метод для генерації коду, або сповістити, що такої відповідності немає.

Цільова програма може бути скомпільовна у виконуємий файл на комп’ютерах з архітектурою IA32.
